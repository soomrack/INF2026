# Информатика — Лекция 04: Строки, кодировки, regex, сложность (весна 2026)

**Преподаватель:** к.ф.-м.н. Михаил Сергеевич Ананьевский

---

## 1) Базовые определения: character / string

- **character** — элемент множества, используемый для представления, организации или управления данными.
- **character literal** — литерал, состоящий из одного символа.
- **string** — последовательность элементов одной природы (например, символов или битов), рассматриваемая как целое.  
(по ISO/IEC 2382:2015)

---

## 2) Таблицы кодировок (примеры)

В лекции показаны таблицы кодировок (как изображения/таблицы символов):
- **ASCII** (стр. 4)
- **CP1251** (стр. 5)
- **KOI8-R** (стр. 6)
- **CP866** (стр. 7)

Идея: один и тот же байт (0–255) может означать *разные символы* в разных однобайтовых кодировках.

---

## 3) Null-terminated strings (C-строки)

**Null-terminated string** — формат хранения строки как непрерывной последовательности байтов, **завершающейся байтом**, у которого все биты равны 0 (`'\0'`).

Пример из лекции:
```cpp
char str[] = "Hello"; // length = 6
printf("%s", str);    // Hello

str[5] = '!';
printf("%s", str);    // Hello!asdf87144bnalk dhg bf1o
````

Ключевая мысль:

* строка `"Hello"` в массиве содержит `H e l l o \0` (поэтому длина = 6)
* если затереть `'\0'`, `printf("%s", ...)` продолжит печатать память дальше, пока случайно не встретит `0`

---

## 4) Unicode и варианты UTF

**Unicode (The Unicode Standard)** — стандарт кодирования символов, поддерживающий письменности мира (поддерживается Unicode Consortium).
В лекции: версия **17.0** задаёт **159’801 символ** и **172 письменности** (scripts).
(ссылка в лекции на ISO/IEC 10646:2020)

Варианты кодирования (encoding forms):

* **UTF-8**
* **UTF-16**
* **UTF-32**
* …

---

## 5) UTF-8 (переменная длина)

**UTF-8** кодирует все допустимые Unicode code points (в лекции: **1’112’064**) с помощью **1–4 байт** (8-bit code units).

В лекции также указано:

* по состоянию на начало **2026 года** ~**99% веб-страниц** используют UTF-8.

Шаблоны байтов (из таблицы на слайде):

| Диапазон code point | Кодирование                                     |
| ------------------- | ----------------------------------------------- |
| U+0000 … U+007F     | `0xxxxxxx` (1 байт)                             |
| U+0080 … U+07FF     | `110xxxxx 10xxxxxx` (2 байта)                   |
| U+0800 … U+FFFF     | `1110xxxx 10xxxxxx 10xxxxxx` (3 байта)          |
| U+010000 … U+10FFFF | `11110xxx 10xxxxxx 10xxxxxx 10xxxxxx` (4 байта) |

---

## 6) Кодирование: fixed-length, префиксный код, Фано

* **Равномерное кодирование (fixed-length code)** — каждый символ алфавита кодируется словом **одинаковой длины**.
* **Префиксный код** — код переменной длины, где **ни одно кодовое слово не является началом другого**.
* **Условие Фано** — формулировка свойства: никакое кодовое слово не может быть началом другого кодового слова.

---

## 7) `std::string` в C++

Базовый пример из лекции:

```cpp
#include <string>
#include <iostream>

...

std::string str;
str = "Hello World";
str.push_back('!');
std::cout << str << std::endl;
```

Ещё операции (пример из лекции):

```cpp
#include <string>

std::string str;
str = "Hello World";

str.resize();
str.length(); // aka str.size(); в байтах

str.insert(2, "adsfda");
str.replace(2, "asdfasd");
```

---

## 8) Алгоритмы на строках (темы)

* сравнение строк
* близость строк (расстояние)
* сортировка строк
* поиск подстроки в строке
* поиск подстроки из словаря в строке

---

## 9) Регулярные выражения (regex)

**Регулярное выражение (regex)** — формальный язык для поиска и манипуляций подстроками в тексте с использованием метасимволов.

Пример из лекции (в терминале):

```bash
echo a1234567b | sed -e 's/[0-9]+/DIGITS/g'
# aDIGITSb
```

Смысл:

* шаблон `[0-9]+` находит одну или более цифр
* замена на `DIGITS` по всему тексту (`g`)

---

## 10) Сложность алгоритмов

**Вычислительная сложность** — количественная оценка ресурсов, необходимых алгоритму, в зависимости от объёма входных данных.

Виды:

* **временная сложность** — зависимость времени выполнения (в “элементарных операциях”) от размера входа
* **пространственная сложность** — зависимость потребления памяти (в байтах) от размера входа

Типичные классы сложности:

* константная `O(1)`
* логарифмическая `O(log n)`
* линейная `O(n)`
* квадратичная `O(n^2)`
* полиномиальная `O(p(n))`
* экспоненциальная `O(2^n)`

---

## 11) Проблема тысячелетия

**P ? NP** — одна из задач тысячелетия (Millennium Prize Problems).

---
